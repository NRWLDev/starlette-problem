{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p><code>starlette_problem</code> is a set of exception base classes and handlers for use in starlette applications to support easy error management and responses</p> <p>Each exception easily marshals to JSON based on the RFC9457 spec for use in api errors.</p>"},{"location":"error/","title":"Errors","text":"<p>The base <code>starlette_problem.error.Problem</code> accepts a <code>title</code>, <code>detail</code>, <code>status</code> (default 500) and optional <code>**kwargs</code>. An additional <code>code</code> can be passed in, which will be used as the <code>type</code>, if not provided the <code>type</code> is derived from the class name.</p> <p>And will return a JSON response with <code>exc.status</code> as the status code and response body:</p> <pre><code>{\n    \"type\": \"an-exception\",\n    \"title\": \"title\",\n    \"detail\": \"detail\",\n    \"status\": 500,\n    \"extra-key\": \"extra-value\",\n    ...\n}\n</code></pre> <p>Derived types are generated using the class name after dropping <code>...Error</code> from the end, and converting to <code>kebab-case</code>. i.e. <code>PascalCaseError</code> will derive the type <code>pascal-case</code>. If the class name doesn't suit your purposes, an optional <code>code</code> attribute can be set with the desired value of there response <code>type</code> field.</p> <p>Some convenience Problems are provided with predefined <code>status</code> attributes. To create custom errors subclasss these and define the <code>title</code> attribute.</p> <ul> <li><code>starlette_problem.error.ServerProblem</code> provides status 500 errors</li> <li><code>starlette_problem.error.RedirectProblem</code> provides status 301 errors</li> <li><code>starlette_problem.error.BadRequestProblem</code> provides status 400 errors</li> <li><code>starlette_problem.error.UnauthorisedProblem</code> provides status 401 errors</li> <li><code>starlette_problem.error.ForbiddenProblem</code> provides status 403 errors</li> <li><code>starlette_problem.error.NotFoundProblem</code> provides status 404 errors</li> <li><code>starlette_problem.error.ConflictProblem</code> provides status 409 errors</li> <li><code>starlette_problem.error.UnprocessableProblem</code> provides status 422 errors</li> </ul>"},{"location":"error/#custom-errors","title":"Custom Errors","text":"<p>Subclassing the convenience classes provide a simple way to consistently raise the same error with detail/extras changing based on the raised context.</p> <pre><code>from starlette_problem.error import NotFoundProblem\n\n\nclass UserNotFoundError(NotFoundProblem):\n    title = \"User not found.\"\n\nraise UserNotFoundError(detail=\"detail\")\n</code></pre> <pre><code>{\n    \"type\": \"user-not-found\",\n    \"title\": \"User not found\",\n    \"detail\": \"detail\",\n    \"status\": 404,\n}\n</code></pre> <p>Whereas a defined <code>code</code> will be used in the output.</p> <pre><code>class UserNotFoundError(NotFoundProblem):\n    title = \"User not found.\"\n    type_ = \"cant-find-user\"\n\nraise UserNotFoundError(detail=\"detail\")\n</code></pre> <pre><code>{\n    \"type\": \"cant-find-user\",\n    \"title\": \"User not found\",\n    \"detail\": \"detail\",\n    \"status\": 404,\n}\n</code></pre> <p>If additional kwargs are provided when the error is raised, they will be included in the output (ensure the provided values are json seriablizable.</p> <pre><code>raise UserNotFoundError(detail=\"detail\", user_id=\"1234\", metadata={\"hello\": \"world\"})\n</code></pre> <pre><code>{\n    ...\n    \"detail\": \"detail\",\n    \"user_id\": \"1234\",\n    \"metadata\": {\"hello\": \"world\"},\n}\n</code></pre>"},{"location":"error/#headers","title":"Headers","text":"<p>Problem subclasses can define specific headers at definition, or provide instance specific headers at raise. These headers will be extracted and returned as part of the response.</p> <p>Headers provided when raising will overwrite any matching headers defined on the class.</p> <pre><code>class HeaderProblem(StatusProblem):\n    status = 400\n    headers = {\"x-define-header\": \"value\"}\n\n\nraise HeaderProblem(headers={\"x-instance-header\": \"value2\"})\n\nresponse.headers == {\n    \"x-define-header\": \"value\",\n    \"x-instance-header\": \"value2\",\n}\n</code></pre>"},{"location":"error/#redirects","title":"Redirects","text":"<p>An additional helper class <code>RedirectProblem</code> is provided for handling 3XX problems with a <code>Location</code> header. This subclass takes an additional required init argument <code>location</code>.</p> <pre><code>class PermanentRedirect(RedirectProblem):\n    status = 308\n    title = \"Permanent redirect\"\n\n\nraise PermanentRedirect(\"https://location\", \"details of move\")\n\ne.headers == {\n    \"Location\": \"https://location\",\n}\n</code></pre>"},{"location":"error/#error-documentation","title":"Error Documentation","text":"<p>The RFC-9457 spec defines that the <code>type</code> field should provide a URI that can link to documentation about the error type that has occurred. By default the Problem class provides a unique identifier for the type, rather than a full url. If your service/project provides documentation on error types, the documentation uri can be provided to the handler which will result in response <code>type</code> fields being converted to a full link. The uri <code>.format()</code> will be called with the type, title, status and any additional extras provided when the error is raised.</p> <pre><code>add_exception_handler(\n    app,\n    documentation_uri_template=\"https://link-to/my/errors/{type}\",\n)\n</code></pre> <pre><code>{\n    \"type\": \"https://link-to/my/errors/an-exception\",\n    ...\n}\n</code></pre> <p>Where a full resolvable documentation uri does not exist, the rfc allows for a tag uri.</p> <pre><code>add_exception_handler(\n    app,\n    documentation_uri_template=\"tag:my-domain.com,2024-01-01:{type}\",\n)\n</code></pre> <pre><code>{\n    \"type\": \"tag:my-domain.com,2024-01-01:an-exception\",\n    ...\n}\n</code></pre>"},{"location":"error/#strict-mode","title":"Strict mode","text":"<p>The RFC-9457 spec defines the type as requiring a URI format, when no reference is provided, it should default to <code>about:blank</code>. Initializing the handler in <code>strict_rfc9457</code> more requires the <code>documentation_uri_template</code> to be defined, and in cases where the Problem doesn't explicitly define a <code>type_</code> attribute, the type will default to <code>about:blank</code>.</p> <pre><code>add_exception_handler(\n    app,\n    documentation_uri_template=\"https://link-to/my/errors/{type}\",\n    strict_rfc9457=True,\n)\n</code></pre> <pre><code>{\n    \"type\": \"about:blank\",\n    ...\n}\n</code></pre>"},{"location":"handlers/","title":"Custom Handler","text":"<p>In the event that you are using a third party library with a custom error class, a handler specifically a common base class can be provided.</p> <p>Providing a custom handler allows for conversion from the custom error class into a <code>Problem</code>, when the exception handler catches it, rather than converting each raised instance into a <code>Problem</code> at the time it is raised.</p>"},{"location":"handlers/#usage","title":"Usage","text":"<p>Given a <code>third_party</code> library with a <code>error.py</code> module.</p> <pre><code>class CustomBaseError(Exception):\n    def __init__(reason: str, debug: str):\n        self.reason = reason\n        self.debug = debug\n</code></pre> <p>A custom handler can then be defined in your application.</p> <pre><code>import starlette.applications\nfrom rfc9457 import error_class_to_type\nfrom starlette_problem.error import Problem\nfrom starlette_problem.handler import ExceptionHandler, add_exception_handler\nfrom starlette.requests import Request\n\nfrom third_party.error import CustomBaseError\n\ndef my_custom_handler(eh: ExceptionHandler, request: Request, exc: CustomBaseError) -&gt; Problem:\n    return Problem(\n        title=exc.reason,\n        detail=exc.debug,\n        type_=error_class_to_type(exc),\n        status=500,\n        headers={\"x-custom-header\": \"value\"},\n    )\n\napp = starlette.applications.Starlette()\nadd_exception_handler(\n    app,\n    handlers={\n        CustomBaseError: my_custom_handler,\n    },\n)\n</code></pre> <p>Any instance of CustomBaseError, or any subclasses, that reach the exception handler will then be converted into a Problem response, as opposed to an unhandled error response.</p>"},{"location":"handlers/#builtin-handlers","title":"Builtin Handlers","text":"<p>Starlette HTTPException instances are handled by default, to customise how these errors are processed, provide a handler for <code>starlette.exceptions.HTTPException</code> similar to the custom handlers previously defined, but rather than passing it to handlers, use the <code>http_exception_handler</code> parameter.</p> <pre><code>import starlette.applications\nfrom starlette.exceptions import HTTPException\nfrom starlette_problem.error import Problem\nfrom starlette_problem.handler import ExceptionHandler, add_exception_handler\nfrom starlette.requests import Request\n\n\ndef my_custom_handler(eh: ExceptionHandler, request: Request, exc: HTTPException) -&gt; Problem:\n    return Problem(...)\n\n\napp = starlette.applications.Starlette()\nadd_exception_handler(\n    app,\n    http_exception_handler=my_custom_handler,\n)\n</code></pre>"},{"location":"handlers/#optional-handling","title":"Optional handling","text":"<p>In some cases you may want to handle specific cases for a type of exception, but let others defer to another handler. In these scenarios, a custom handler can return None rather than a Problem. If a handler returns None the exception will be pass to the next defined handler.</p> <pre><code>import starlette.applications\nfrom rfc9457 import error_class_to_type\nfrom starlette_problem.error import Problem\nfrom starlette_problem.handler import ExceptionHandler, add_exception_handler\nfrom starlette.requests import Request\n\ndef no_response_handler(eh: ExceptionHandler, request: Request, exc: RuntimeError) -&gt; Problem | None:\n    if str(exc) == \"No response returned.\":\n        return Problem(\n            title=\"No response returned.\",\n            detail=\"starlette bug\",\n            type_=\"no-response\",\n            status=409,\n        )\n    return None\n\ndef base_handler(eh: ExceptionHandler, request: Request, exc: Exception) -&gt; Problem:\n    return Problem(\n        title=exc.reason,\n        detail=exc.debug,\n        type_=error_class_to_type(exc),\n        status=500,\n    )\n\napp = starlette.applications.Starlette()\nadd_exception_handler(\n    app,\n    handlers={\n        RuntimeError: no_response_handler,\n        Exception: base_handler,\n    },\n)\n</code></pre> <p>At the time of writing there was (is?) a bug in starlette that would cause middlewares to error.  To prevent these from reaching Sentry, a deferred handler was implemented in the impacted project.</p>"},{"location":"hooks/","title":"Hooks","text":"<p>Custom pre/post hook functions can be provided to the exception handler.</p>"},{"location":"hooks/#pre-hooks","title":"Pre Hooks","text":"<p>A pre hook will be provided with the current request, and exception. There should be no side effects in pre hooks and no return value, they can be used for informational purposes such as logging or debugging.</p> <pre><code>import logging\n\nimport starlette.applications\nfrom starlette_problem.handler import add_exception_handler\nfrom starlette.requests import Request\n\nlogger = logging.getLogger(__name__)\n\n\ndef custom_hook(request: Request, exc: Exception) -&gt; None:\n    logger.debug(type(exc))\n    logger.debug(request.headers)\n\n\napp = starlette.applications.Starlette()\nadd_exception_handler(\n    app,\n    pre_hooks=[custom_hook],\n)\n</code></pre>"},{"location":"hooks/#post-hooks","title":"Post Hooks","text":"<p>A post hook will be provided with the raw content object, the incoming request, and the current response object. Post hooks can mutate the response object to provide additional headers etc. The CORS header implementation is done using a post hook. In the case the response format should be changed (if you have an xml api etc, the raw content can be reprocessed.).</p> <pre><code>import starlette.applications\nfrom starlette_problem.handler import add_exception_handler\nfrom starlette.requests import Request\n\nlogger = logging.getLogger(__name__)\n\n\ndef custom_hook(content: dict, request: Request, response: Response) -&gt; Response:\n    if \"x-custom-header\" in request.headers:\n        response.headers[\"x-custom-response\"] = \"set\"\n\n    return content, response\n\n\napp = starlette.applications.Starlette()\nadd_exception_handler(\n    app,\n    post_hooks=[custom_hook],\n)\n</code></pre>"},{"location":"openapi/","title":"Openapi Support","text":"<p><code>starlette-problem</code> expands on the builtin support for openapi generation described here to provide Problem component and response generation.</p> <p>On top of the base schema generation, some additional init parameters have been introduced to configure problem component definition in line with the exception handler configuration.</p>"},{"location":"openapi/#custom-components","title":"Custom components","text":"<p>As a default, the schema generator will inject a <code>Problem</code> component that can be used in docstrings when defining an error response. If there is one or more specific Problem subclasses that are convenient to include in the openapi component definition, these can be passed in with the schema definition.</p> <pre><code>from starlette_problem.schemas import SchemaGenerator\n\nschemas = SchemaGenerator(\n    {\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Example API\", \"version\": \"1.0\"}},\n    problems=[UnauthorisedProblem],\n)\n</code></pre>"},{"location":"openapi/#response-customisation","title":"Response customisation","text":"<p>General usage is to define a response object linked to a component in the docstring.</p> <pre><code>def list_users(request):\n    \"\"\"\n    responses:\n      200:\n        description: A list of users.\n        examples:\n          [{\"username\": \"tom\"}, {\"username\": \"lucy\"}]\n      401:\n        content:\n          application/problem+json:\n            schema:\n              $ref: '#/components/schemas/UnauthorisedProblem'\n    \"\"\"\n</code></pre> <p>A generic <code>4XX</code> and <code>5XX</code> response can be added to each path, these can be opted into by passing <code>generic_defaults=True</code> when defining the schema object.</p> <pre><code>from starlette_problem.schemas import SchemaGenerator\n\nschemas = SchemaGenerator(\n    {\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Example API\", \"version\": \"1.0\"}},\n    generic_defaults=True,\n)\n</code></pre> <p>If the <code>starlette-problem</code> exception handler has been defined with a custom documentation uri, or in strict mode, these can both be defined with the schema definition to ensure documentation lines up with reality.</p> <pre><code>from starlette_problem.schemas import SchemaGenerator\n\nschemas = SchemaGenerator(\n    {\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Example API\", \"version\": \"1.0\"}},\n    documentation_uri_template=\"my_uri_template\",\n    strict=True,\n)\n</code></pre>"},{"location":"openapi/#openapijson","title":"openapi.json","text":"<p>In addition to the supported openapi schema response, <code>starlette-problem</code> supports generation of <code>openapi.json</code> as well.</p> <pre><code>def openapi_schema(request):\n    return schemas.OpenAPIResponse(request=request)\n\ndef openapi_json(request):\n    return schemas.OpenAPIJsonResponse(request=request)\n\nroutes = [\n    Route(\"/schema\", endpoint=openapi_schema, include_in_schema=False),\n    Route(\"/openapi.json\", endpoint=openapi_json, include_in_schema=False),\n]\n\napp =  Starlette(routes=routes)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<pre><code>import starlette.applications\nimport starlette_problem.handler\n\n\napp = starlette.applications.Starlette()\nstarlette_problem.handler.add_exception_handler(app)\n</code></pre> <p>A custom logger can be provided using:</p> <pre><code>add_exception_handler(\n    app,\n    logger=...,\n)\n</code></pre> <p>If you require cors headers, you can pass a <code>starlette_problem.cors.CorsConfiguration</code> instance to <code>add_exception_handler(cors=...)</code>.</p> <pre><code>add_exception_handler(\n    app,\n    cors=CorsConfiguration(\n        allow_origins=[\"*\"],\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n        allow_credentials=True,\n    )\n)\n</code></pre> <p>To customise the way that errors, that are not a subclass of Problem, are handled provide <code>unhandled_wrappers</code>, a dict mapping an http status code to a <code>StatusProblem</code>, the system key <code>default</code> is also accepted as the root wrapper for all unhandled exceptions.</p> <pre><code>from starlette_problem.error import StatusProblem\nfrom starlette_problem.handler import add_exception_handler\n\nclass NotFoundError(StatusProblem):\n    status = 404\n    message = \"Endpoint not found.\"\n\nadd_exception_handler(\n    app,\n    unhandled_wrappers={\n        \"404\": NotFoundError,\n    },\n)\n</code></pre> <p>If you wish to hide debug messaging from external users, <code>StripExtrasPostHook</code> allows modifying the response content. <code>mandatory_fields</code> supports defining fields that should always be returned, default fields are <code>[\"type\", \"title\", \"status\", \"detail\"]</code>.</p> <p>For more fine-grained control, <code>exclude_status_codes=[500, ...]</code> can be used to allow extras for specific status codes. Alternatively if you have a lot of exclusions, <code>include_status_codes=[400, ...]</code> can be used to determine which status_codes to strip extras for. Allowing expected fields to reach the user, while suppressing unexpected server errors etc.</p> <pre><code>from starlette_problem.handler import StripExtrasPostHook, add_exception_handler\n\nadd_exception_handler(\n    app,\n    post_hooks=[\n        StripExtrasPostHook(\n            mandatory_fields=[\"type\", \"title\", \"status\", \"detail\", \"custom-extra\"],\n            exclude_status_codes=[400],\n            enabled=True,\n        )\n    ],\n)\n</code></pre>"},{"location":"usage/#sentry","title":"Sentry","text":"<p><code>starlette_problem</code> is designed to play nicely with Sentry, there is no need to do anything special to integrate with sentry other than initializing the sdk. The Starlette integration paired with the Logging integration will take care of everything.</p> <p>To prevent duplicated entries, ignoing the <code>uvicorn.error</code> logger in sentry can be handy.</p>"}]}